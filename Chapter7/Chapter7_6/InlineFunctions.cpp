#include <iostream>

using namespace std;

inline int min(int x, int y)
{
	return x > y ? y : x;
}

// inline을 쓰면, 강제로 함수를 inline으로 만드는 게 아니고, 컴파일러에게 이렇게 좀 해주세요 하고 권유하는 정도이다
// 컴파일러가 inline으로 컴파일할지 고려해보도록 만드는 정도라고 보면 되는데
// 컴파일러가 진짜로 inline을 적용시켜줬을지 어떨지는 알기 어렵다

// 모든 함수를 inline으로 바꾼다고 해서 빨라지는 것은 절대 아니다! Never

// 요즘 컴파일러들은 아주 좋아져서, 자신이 생각할 때, 논리적으로 따져봤을 떄
// 이 부분 inline 넣으면 빨라지겠네 싶으면, 알아서 바꾼다 
// => 따라서, 최근에는 inline을 넣는다고 빨라진다는 보장이 없고
// 안 쓴다고 안 빨라진다는 보장이 없다라는 식으로 얘기가 나오고 있다

// 이렇다보니, 코딩할 때 inline에 의존해서 최적화를 하려고 하면 좋지 않다
// 코딩 테크닉으로 최적화를 하는 것보다는, 소프트웨어의 구조 자체를 바꾸는 식으로
// 예를 들면, OOP, Data-driven programming ?
// 데이터 드리븐을 이용해서, 하드웨어 가속을 잘 받는 식으로, 캐쉬 미스를 줄이는 방향으로 코딩을 한다던지
// GPU 가속을 받는다던가, 병렬처리를 잘 한다던가 <- 이런 식으로 하는 게 현대적인 최적화 방식이다

int main()
{
	cout << min(5, 6) << endl;
	cout << min(3, 2) << endl;

	// inline을 적용한 함수는 밑에 쓴 코드처럼 컴파일이 된다, 컴파일러가 알아서 한다는 뜻
	cout << (5 > 6 ? 6 : 5) << endl; // 이렇게 쓰면 함수가 호출될 일도 없고, 로컬변수를 만들 필요도 없어지니
	cout << (3 > 2 ? 2 : 3) << endl; // 속도가 향상되게 된다고 하는데, 이 주제에 대해서는 여러 의견이 분분하다
}